{"ts":1347319830239,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1347445430188,"patch":[[{"diffs":[[1,"#ifndef ADT_H_\n#define ADT_H_\n\n#include <stddef.h>\n#include \"adtdefs.h\"\n\n#define adt_INVALIDPOS ((size_t)-1)\n\n/**\n * Enumeration of all the library's error codes.\n */\ntypedef enum adt_EEcode_t {\n    \n      adt_EC_OK    /**< Operation successful. */\n    , adt_EC_ERROR /**< An error ocurred. */\n    , adt_EC_NIMPL /**< Not implemented. */\n    , adt_EC_NSUPP /**< Not supported. */\n    , adt_EC_NOMEM /**< Out of memory. */\n    \n    /* ... */\n    \n    , adt_EC_MAX   /**< Placeholder, for the maximum error code value. */\n} adt_EEcode;\n\n/**\n * Enumerates all possible results of a value comparison.\n */\ntypedef enum adt_ECmpResult_t {\n    \n      adt_CMP_ERR = -2  /**< Values are not comparable. */\n    , adt_CMP_LT        /**< Value is less than another. */\n    , adt_CMP_EQ        /**< Value is equals another. */\n    , adt_CMP_GT        /**< Value is greater than another. */\n} adt_ECmpResult;\n\n/**\n * Enumeration of all the library's container types.\n */\ntypedef enum adt_EType_t {\n    \n      adt_TYPE_NONE    /**< For cases where the container state is invalid. */\n    , adt_TYPE_VECTOR  /**< A simple, contiguous array of values. */\n    , adt_TYPE_DLIST   /**< A doubly-linked list. */\n    , adt_TYPE_DEQUE   /**< A vector-like container, with efficient\n                            insertion and deletion at both ends. */\n    , adt_TYPE_VSET    /**< A list of unique elements. */\n    , adt_TYPE_VMAP    /**< A key-value associative mapping. */\n    , adt_TYPE_HASHSET /**< A hash-based map. */\n    , adt_TYPE_HASHMAP /**< A hash-based set. */\n    , adt_TYPE_BITSET  /**< A set of bits, akin to C++ STL's bitset. */\n} adt_EType;\n\n/**\n * Enumeration of all categories of containers.\n */\ntypedef enum adt_ECategory_t {\n    \n      adt_CAT_NONE  /**< The container does not fit in any category. */\n    , adt_CAT_BIT   /**< Exclusive for bitsets. */\n    , adt_CAT_LIST  /**< Lists of ordered values. */\n    , adt_CAT_SET   /**< Lists of unique values. */\n    , adt_CAT_MAP   /**< Mapping of unique keys to arbitrary values. */\n} adt_ECategory;\n\n/**\n * Enumeration of all the library's supported value types.\n */\ntypedef enum adt_EValueType_t {\n    \n      adt_VTYPE_NONE = 0\n    , adt_VTYPE_CTNR\n    , adt_VTYPE_PAIR\n    , adt_VTYPE_ITER\n    , adt_VTYPE_CUSTOM\n    \n    , adt_VTYPE_CHAR\n    , adt_VTYPE_UCHAR\n    , adt_VTYPE_SHORT\n    , adt_VTYPE_USHORT\n    , adt_VTYPE_INT\n    , adt_VTYPE_UINT\n    , adt_VTYPE_LONG\n    , adt_VTYPE_ULONG\n    \n    , adt_VTYPE_FLOAT\n    , adt_VTYPE_DOUBLE\n    , adt_VTYPE_LDOUBLE\n    \n    , adt_VTYPE_VOIDP\n    , adt_VTYPE_CHARP\n    , adt_VTYPE_WCHARP\n    \n    , adt_VTYPE_SIZET\n    , adt_VTYPE_PTRDT\n    , adt_VTYPE_WCHAR\n} adt_EValueType;\n\n/**\n * Opaque type to a generic container.\n * All other library functions will use pointers to this typedef.\n */\ntypedef struct adt_Container_t adt_Container;\n\n/**\n * Type definition for @a adt_Pair_t.\n */\ntypedef struct adt_Pair_t adt_Pair;\n\n/**\n * An opaque object used to hold the state of iteration over a collection.\n */\ntypedef struct adt_Iterator_t adt_Iterator;\n\n/**\n * An opaque object used to hold a reference to a specific object inside a\n * container.\n */\ntypedef struct adt_Reference_t adt_Reference;\n\n/**\n * Amalgamation of all supported value types.\n * Value passing is supposed to be done through these specialized objects.\n * They're meant to be passed by value, not by reference (to avoid having to\n * manage memory for simple values).\n */\ntypedef struct adt_Value_t {\n    \n    adt_EValueType vtype;\n    union {\n        size_t vsize;\n        adt_EType ctype;\n    }\n    union {\n        /* Library types */\n        adt_Container *ctnr;\n        adt_Pair *pair;\n        adt_Iterator *iter;\n        \n        /* Integers */\n        char c;\n        unsigned char uc;\n        short int sd;\n        unsigned short int usd;\n        int d;\n        unsigned int ud;\n        long int l;\n        unsigned long int ul;\n        \n        /* Floats */\n        float f;\n        double d;\n        long double ld;\n        \n        /* Pointers */\n        void *vp;\n        char *cp;\n        wchar_t wcp;\n        \n        /* stddef types */\n        size_t sz;\n        ptrdiff_t pd;\n        wchar_t wc;\n    };\n} adt_Value;\n\n/**\n * A simple pair of values, used in some functions.\n */\nstruct adt_Pair_t {\n    \n    union {\n        adt_Value key;\n        size_t idx;\n    };\n    adt_Value val;\n};\n\n/**\n * Signature for a function that makes a hash out of a specific value.\n */\ntypedef size_t (*adt_FHash)(adt_Value val);\n\n/**\n * Signature for a function that manages memory allocation and deallocation.\n * Its interface is the exact same as @c stdlib's @c realloc.\n */\ntypedef void* (*adt_FAlloc)(void *ptr, size_t sz);\n\n/**\n * Signature for a function that compares two values.\n * @see adt_ECmpResult\n */\ntypedef adt_ECmpResult (*adt_FCompare)(adt_Value obj, adt_Value other);\n\n/**\n * Signature for a function that finalizes values.\n */\ntypedef void (*adt_FFinalize)(adt_Value value);\n\n/**\n * An utility object to hold container creation parameters.\n */\ntypedef struct adt_Options_t {\n    \n    adt_EType type;          /**< Container type and implementation. */\n    adt_EValueType ktype;    /**< Value for the key, in case of maps. */\n    adt_EValueType vtype;    /**< Value for maps, in case of lists or sets. */\n    size_t cap;              /**< Capacity of the container, in elements. */\n    size_t size;             /**< Size of the container, in elements. */\n    size_t ksize;            /**< Size, in bytes, for the keys. */\n    size_t vsize;            /**< Size, in bytes, for the values. */\n    adt_FHash hashf;         /**< The hashing function. */\n    adt_FAlloc allocf;       /**< The memory management function. */\n    adt_FCompare comparef;   /**< The comparison function. */\n    adt_FFinalize finalizef; /**< A finalizer for a value. */\n    char immutable;          /**< If true, container is immutable. */\n    char noresize;           /**< If true, container won't resize itself. */\n    \n    adt_EEcode ecode;        /**< In case of errors, indicates what happened. */\n} adt_Options;\n\n\n/**\n * @section adt_base_misc Miscellaneous functions\n */\n\nadt_API adt_ECategory adt_getcategoryfor(adt_EType ctype);\nadt_API size_t adt_getmaxsizefor(adt_EType ctype);\nadt_API adt_ECategory adt_getcategory(adt_Container *C);\nadt_API size_t adt_getmaxsize(adt_Container *C);\nadt_API adt_EEcode adt_getecode(adt_Container *C);\nadt_API adt_ECmpResult adt_valuecompare(adt_Value obj, adt_Value other);\nadt_API size_t adt_valuehash(adt_Value val);\n\n/**\n * @section adt_base_create Creating containers\n */\n\nadt_API adt_Container *adt_new(adt_EType ctype);\nadt_API adt_Container *adt_newwith(adt_Options *options);\nadt_API adt_Container *adt_newfrom(adt_Container *C, adt_EType ctype);\nadt_API void adt_free(adt_Container *C);\nadt_API adt_Container *adt_copy(adt_Container *C);\n\n/**\n * @section adt_base_oper Basic operations\n */\n\nadt_API adt_Value adt_at(adt_Container *C, size_t sz);\nadt_API adt_Value adt_on(adt_Container *C, adt_Value val);\nadt_API size_t adt_has(adt_Container *C, adt_Value v);\nadt_API size_t adt_hasat(adt_Container *C, size_t idx);\nadt_API size_t adt_hasvalue(adt_Container *C, adt_Value v);\nadt_API adt_Value adt_setat(adt_Container *C, size_t sz, adt_Value val);\nadt_API adt_Value adt_seton(adt_Container *C, adt_Value key, adt_Value val);\nadt_API adt_EEcode adt_pushl(adt_Container *C, adt_Value val);\nadt_API adt_EEcode adt_pushr(adt_Container *C, adt_Value val);\nadt_API adt_Value adt_popl(adt_Container *C, adt_Value val);\nadt_API adt_Value adt_popr(adt_Container *C, adt_Value val);\nadt_API adt_EEcode adt_insertat(adt_Container *C, size_t sz, adt_Value val);\nadt_API adt_EEcode adt_inserton(adt_Container *C, adt_Value key, adt_Value val);\nadt_API adt_Value adt_removeat(adt_Container *C, size_t sz);\nadt_API adt_Value adt_removeon(adt_Container *C, adt_Value key);\n\n#define adt_insat(i) adt_insertat(i)\n#define adt_inson(i) adt_inserton(i)\n#define adt_delat(i) adt_removeat(i)\n#define adt_delon(i) adt_removeon(i)\n\n/**\n * @section adt_base_adaptors Adaptor functions\n */\n\nadt_API adt_Value\n\n\n/**\n * @section adt_base_opts Checking and setting Container options\n */\n\nadt_API const adt_Options* adt_getoptions(adt_Container *C);\nadt_API int adt_canresize(adt_Container *C);\nadt_API int adt_canchange(adt_Container *C);\nadt_API int adt_isempty(adt_Container *C);\nadt_API size_t adt_getsize(adt_Container *C);\nadt_API size_t adt_getcap(adt_Container *C);\n\nadt_API adt_EEcode adt_setimmutable(adt_Container *C);\nadt_API int adt_setnoresize(adt_Container *C, int flag);\nadt_API adt_EEcode adt_sethashf(adt_Container *C, adt_FHash hashf);\nadt_API adt_EEcode adt_setfinalizerf(adt_Container *C, adt_FFinalize finalizef);\nadt_API adt_EEcode adt_setcomparef(adt_Container *C, adt_FCompare hashf);\n\nadt_API adt_EEcode adt_resize(adt_Container *C, size_t sz, adt_Value *fill);\nadt_API adt_EEcode adt_reserve(adt_Container *C, size_t sz);\nadt_API adt_EEcode adt_swap(adt_Container *C, adt_Container *O);\nadt_API void adt_clear(adt_Container *C);\n\n/**\n * @section adt_base_iter Iterators\n */\n\nadt_API adt_Iterator* adt_ibegin(adt_Container *C);\nadt_API adt_Iterator* adt_iend(adt_Container *C);\nadt_API adt_Iterator* adt_irbegin(adt_Container *C);\nadt_API adt_Iterator* adt_irend(adt_Container *C);\nadt_API adt_Iterator* adt_ibeginat(adt_Container *C, size_t pos);\nadt_API adt_Iterator* adt_irbeginat(adt_Container *C, size_t pos);\nadt_API adt_Iterator* adt_ibeginon(adt_Container *C, adt_Value val);\nadt_API adt_Iterator* adt_irbeginon(adt_Container *C, adt_Value val);\n\nadt_API adt_Value adt_Iterator_actual(adt_Iterator *I);\nadt_API adt_Value adt_Iterator_next(adt_Iterator *I);\nadt_API adt_Value adt_Iterator_previous(adt_Iterator *I);\nadt_API int adt_Iterator_hasnext(adt_Iterator *I);\nadt_API int adt_Iterator_hasprevious(adt_Iterator *I);\nadt_API int adt_Iterator_getdirection(adt_Iterator *I);\nadt_API size_t adt_Iterator_getpos(adt_Iterator *I);\nadt_API adt_Value adt_Iterator_getvalue(adt_Iterator *I);\nadt_API adt_EEcode adt_Iterator_getecode(adt_Iterator *I);\nadt_API adt_EEcode adt_Iterator_remove(adt_Iterator *I);\nadt_API adt_EEcode adt_Iterator_setvalue(adt_Iterator *I, adt_Value val);\nadt_API void adt_Iterator_free(adt_Iterator *I);\n\n#define adt_iactual(i) adt_Iterator_actual(i)\n#define adt_inext(i) adt_Iterator_next(i)\n#define adt_iprev(i) adt_Iterator_previous(i)\n#define adt_ihasnext(i) adt_Iterator_hasnext(i)\n#define adt_ihasprev(i) adt_Iterator_hasprevious(i)\n#define adt_igetdir(i) adt_Iterator_getdirection(i)\n#define adt_igetpos(i) adt_Iterator_getpos(i)\n#define adt_igetval(i) adt_Iterator_getvalue(i)\n#define adt_igetecode(i) adt_Iterator_geterror(i)\n#define adt_iremove(i) adt_Iterator_remove(i)\n#define adt_isetval(i, v) adt_Iterator_setvalue(i, v)\n#define adt_ifree(i) adt_Iterator_free(i)\n\n#endif\n\n"]],"start1":0,"start2":0,"length1":0,"length2":10810}]],"length":10810,"saved":false}
{"ts":1347446248648,"patch":[[{"diffs":[[0,"r;\n\n"],[-1,"/**\n * An opaque object used to hold a reference to a specific object inside a\n * container.\n */\ntypedef struct adt_Reference_t adt_Reference;\n\n"],[0,"/**\n"]],"start1":3037,"start2":3037,"length1":152,"length2":8},{"diffs":[[0," types.\n"],[1,""],[0," * Value"]],"start1":3083,"start2":3083,"length1":16,"length2":16},{"diffs":[[0,"*/\n\n"],[-1,"adt_API adt_Value adt_at(adt_Container *C, size_t sz);\nadt_API adt_Value adt_on(adt_Container *C, adt_Value val);\n"],[0,"adt_"]],"start1":6740,"start2":6740,"length1":122,"length2":8},{"diffs":[[0,", adt_Value v);\n"],[1,"adt_API adt_Value adt_at(adt_Container *C, size_t sz);\nadt_API adt_Value adt_on(adt_Container *C, adt_Value val);\n"],[0,"adt_API adt_Valu"]],"start1":6899,"start2":6899,"length1":32,"length2":146},{"diffs":[[0,"ner *C);"],[1,"\nadt_API size_t adt_getcount(adt_Container *C);"],[0,"\n\nadt_AP"]],"start1":8288,"start2":8288,"length1":16,"length2":63},{"diffs":[[0,"e(i, v)\n"],[-1,""],[0,"#define "]],"start1":10654,"start2":10654,"length1":16,"length2":16},{"diffs":[[0,"ree(i)\n\n"],[1,"\n/**\n * @section adt_base_ref References\n */\n\nadt_API adt_Reference* \n\n"],[0,"#endif\n\n"]],"start1":10697,"start2":10697,"length1":16,"length2":87}]],"length":10784,"saved":false}
